#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import cv2
import numpy as np
import time
from dataclasses import dataclass
from ultralytics import YOLO
from time import sleep
import RPi.GPIO as GPIO

# =======================================================
# ‚öôÔ∏è GPIO CONFIGURATION (Servo Motor Control)
# =======================================================
GPIO.setwarnings(False)
GPIO_MODE = True  # ‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô False ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Æ‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏ß‡∏£‡πå

if GPIO_MODE:
    SERVO_PIN_B = 19
    SERVO_PIN_C = 13
    PWM_FREQ = 50
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(SERVO_PIN_B, GPIO.OUT)
    GPIO.setup(SERVO_PIN_C, GPIO.OUT)
    servo_pwm1 = GPIO.PWM(SERVO_PIN_B, PWM_FREQ)
    servo_pwm2 = GPIO.PWM(SERVO_PIN_C, PWM_FREQ)
    servo_pwm1.start(0)
    servo_pwm2.start(0)
    print("[GPIO MODE] ‚úÖ Motor control ENABLED")
else:
    servo_pwm1 = None
    servo_pwm2 = None
    print("[SIMULATION MODE] ‚ùå Motor control DISABLED")

current_duty = 0
current_angle = 90

def angle_to_duty(angle: float) -> float:
    """‡∏°‡∏∏‡∏° 0‚Äì180¬∞ ‚Üí duty cycle 2‚Äì12%"""
    return 2 + (angle / 18.0)

def move_to(angle: float):
    """‡∏´‡∏°‡∏∏‡∏ô servo ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß"""
    global current_duty, current_angle
    angle = np.clip(angle, 0, 180)
    duty = angle_to_duty(angle)
    if GPIO_MODE:
        servo_pwm1.ChangeDutyCycle(duty)
        servo_pwm2.ChangeDutyCycle(duty)
    current_duty = duty
    current_angle = angle
    print(f"[SERVO] Angle={angle:.1f}¬∞ Duty={duty:.2f}%")
    sleep(0.05)
    if GPIO_MODE:
        servo_pwm1.ChangeDutyCycle(0)
        servo_pwm2.ChangeDutyCycle(0)

def stop_servo():
    """‡∏´‡∏¢‡∏∏‡∏î PWM"""
    if GPIO_MODE:
        servo_pwm1.stop()
        servo_pwm2.stop()
        GPIO.cleanup()
    print("[GPIO] Cleaned up")

# =======================================================
# ‚öôÔ∏è CONFIGURATION
# =======================================================
@dataclass
class Config:
    model_path: str = "/home/rpi/yolo/yolo11n.pt"
    source: str = "0"
    resolution: tuple = (640, 480)
    conf_thresh: float = 0.4
    imgsz: int = 320
    steering_gain: float = 0.04
    max_angle: float = 30.0
    roi_ratio: float = 0.6
    canny_low: int = 75
    canny_high: int = 150
    focal_length: float = 700.0
    normal_speed: int = 50  # km/h (‡∏à‡∏≥‡∏•‡∏≠‡∏á)

# =======================================================
# üõ£Ô∏è LANE DETECTOR
# =======================================================
class LaneDetector:
    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.prev_lanes = []

    def detect_lanes(self, frame):
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(gray, (5, 5), 0)
        edges = cv2.Canny(blur, self.cfg.canny_low, self.cfg.canny_high)
        h, w = edges.shape
        mask = np.zeros_like(edges)
        pts = np.array([[
            (int(w * 0.1), h),
            (int(w * 0.4), int(h * self.cfg.roi_ratio)),
            (int(w * 0.6), int(h * self.cfg.roi_ratio)),
            (int(w * 0.9), h)
        ]], np.int32)
        cv2.fillPoly(mask, pts, 255)
        roi = cv2.bitwise_and(edges, mask)
        lines = cv2.HoughLinesP(roi, 1, np.pi / 180, 30,
                                minLineLength=40, maxLineGap=30)
        if lines is None:
            return self.prev_lanes

        left, right = [], []
        for x1, y1, x2, y2 in lines[:, 0]:
            if x2 - x1 == 0:
                continue
            slope = (y2 - y1) / (x2 - x1)
            if abs(slope) < 0.4 or abs(slope) > 1.0:
                continue
            if slope < 0:
                left.append((x1, y1, x2, y2))
            else:
                right.append((x1, y1, x2, y2))
        lanes = []
        if left:
            lanes.append(self._average_line(left, h))
        if right:
            lanes.append(self._average_line(right, h))
        if lanes:
            self.prev_lanes = lanes
        return lanes

    def _average_line(self, lines, height):
        xs, ys = [], []
        for x1, y1, x2, y2 in lines:
            xs += [x1, x2]
            ys += [y1, y2]
        slope, intercept = np.polyfit(xs, ys, 1)
        y1, y2 = height, int(height * 0.6)
        x1, x2 = int((y1 - intercept) / slope), int((y2 - intercept) / slope)
        return [x1, y1, x2, y2]

    def draw_lanes(self, frame, lanes):
        out = frame.copy()
        for x1, y1, x2, y2 in lanes:
            cv2.line(out, (x1, y1), (x2, y2), (0, 255, 255), 5)
        return out

    def get_lane_mask(self, shape, lanes):
        mask = np.zeros(shape[:2], dtype=np.uint8)
        if len(lanes) == 2:
            pts = np.array([[
                (lanes[0][0], lanes[0][1]),
                (lanes[0][2], lanes[0][3]),
                (lanes[1][2], lanes[1][3]),
                (lanes[1][0], lanes[1][1])
            ]], np.int32)
            cv2.fillPoly(mask, pts, 255)
        return mask

# =======================================================
# üß≠ LANE KEEPER
# =======================================================
class LaneKeeper:
    def __init__(self, cfg: Config):
        self.cfg = cfg
        self.angle = 0.0

    @staticmethod
    def _x_at_y(line, y_ref):
        x1, y1, x2, y2 = line
        if x2 == x1: return x1
        slope = (y2 - y1) / (x2 - x1)
        intercept = y1 - slope * x1
        return int((y_ref - intercept) / slope)

    def calculate_steering(self, lanes, shape):
        h, w = shape[:2]
        if len(lanes) < 2: return None, None, None
        lanes_sorted = sorted(lanes, key=lambda x: x[0])
        left, right = lanes_sorted[0], lanes_sorted[1]
        y_ref = int(h * 0.9)
        x_left = self._x_at_y(left, y_ref)
        x_right = self._x_at_y(right, y_ref)
        lane_center = int((x_left + x_right) / 2)
        image_center = w // 2
        deviation = lane_center - image_center
        steering_angle = np.clip(-deviation * self.cfg.steering_gain, -1, 1)
        steering_deg = steering_angle * self.cfg.max_angle
        return steering_deg, deviation, (lane_center, y_ref)

# =======================================================
# üßÆ DISTANCE + SPEED
# =======================================================
def estimate_distance(cfg, box_h, label):
    real_height_map = {"person": 1.7, "car": 1.5, "truck": 3.0,
                       "motorcycle": 1.2, "bicycle": 1.5}
    real_h = real_height_map.get(label, 1.5)
    if box_h <= 0: return np.inf
    return round((cfg.focal_length * real_h) / box_h, 2)

def suggest_speed(distance, cfg):
    if distance < 3: return 0
    elif distance < 7: return 15
    elif distance < 15: return 30
    else: return cfg.normal_speed

# =======================================================
# üöò MAIN LOOP
# =======================================================
def main(cfg: Config):
    print("[INFO] Loading YOLO model...")
    model = YOLO(cfg.model_path)
    lane_detector = LaneDetector(cfg)
    keeper = LaneKeeper(cfg)

    cap = cv2.VideoCapture(int(cfg.source))
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, cfg.resolution[0])
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, cfg.resolution[1])

    while True:
        ret, frame = cap.read()
        if not ret: continue

        start = time.time()
        lanes = lane_detector.detect_lanes(frame)
        frame_lanes = lane_detector.draw_lanes(frame, lanes)
        steering_angle, offset_px, lane_center = keeper.calculate_steering(lanes, frame.shape)
        lane_mask = lane_detector.get_lane_mask(frame.shape, lanes)

        # --- YOLO DETECTION ---
        results = model.predict(frame, imgsz=cfg.imgsz, conf=cfg.conf_thresh, verbose=False)
        det = results[0].boxes

        in_lane_objs, min_dist_in_lane = [], np.inf
        for box in det:
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            label = model.names[int(box.cls[0])]
            box_h = y2 - y1
            dist = estimate_distance(cfg, box_h, label)
            cx, cy = (x1 + x2)//2, (y1 + y2)//2
            inside_lane = lane_mask[cy, cx] == 255 if lanes else False
            color = (0, 255, 0) if not inside_lane else (0, 0, 255)
            cv2.rectangle(frame_lanes, (x1, y1), (x2, y2), color, 2)
            cv2.putText(frame_lanes, f"{label} {dist:.1f}m",
                        (x1, max(20, y1-5)), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
            if inside_lane:
                in_lane_objs.append((label, dist))
                min_dist_in_lane = min(min_dist_in_lane, dist)

        # --- SPEED DECISION ---
        suggested_speed = suggest_speed(min_dist_in_lane, cfg) if in_lane_objs else cfg.normal_speed
        status = "üü¢ No Object in Lane" if not in_lane_objs else f"üî¥ Object {min_dist_in_lane:.1f}m Ahead"
        cv2.putText(frame_lanes, f"Speed: {suggested_speed} km/h", (10, 90),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,255,0) if suggested_speed>0 else (0,0,255), 2)
        cv2.putText(frame_lanes, status, (10, 60),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,255), 2)

        # --- SERVO CONTROL ---
        if steering_angle is not None:
            move_to(90 + steering_angle)

        # --- OVERLAY INFO ---
        fps = 1.0 / (time.time() - start + 1e-6)
        cv2.putText(frame_lanes, f"FPS: {fps:.1f}", (10, 25),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255,255,255), 2)

        cv2.imshow("YOLO + Lane + Speed + Servo", frame_lanes)
        key = cv2.waitKey(1) & 0xFF
        if key in [ord('q'), 27]:
            break

    cap.release()
    cv2.destroyAllWindows()
    stop_servo()

# =======================================================
# üöÄ EXECUTION
# =======================================================
if __name__ == "__main__":
    try:
        cfg = Config()
        main(cfg)
    except KeyboardInterrupt:
        stop_servo()
